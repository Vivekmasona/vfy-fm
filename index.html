<style>
body {
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #f0f0f0;
}

#controls {
    text-align: center;
    padding: 20px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

button {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    margin: 5px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s;
}

button:disabled {
    background: #ccc;
    cursor: not-allowed;
}

button:hover:not(:disabled) {
    background: #45a049;
}

#callStatus {
    display: block;
    margin-top: 10px;
    font-weight: bold;
}

#incomingCall {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 40%;
    height: 25px;
    background: #ffeb3b;
    border-radius: 15px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    font-weight: bold;
}

#incomingCall p {
    margin: 0;
    font-size: 14px;
    flex: 1;
    text-align: center;
}

#incomingCall button {
    background: #2196F3;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 2px 10px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.3s;
}

#incomingCall button:hover {
    background: #1976D2;
}

#callTimer {
    font-size: 12px;
    margin-left: 10px;
    color: #555;
}
</style>

<div id="controls">
    <button id="callUser" disabled>Call User</button>
    <button id="endCall" style="display: none;">End Call</button>
    <span id="callStatus">Not Connected</span>
    <span id="callTimer">00:00</span>
</div>

<div id="incomingCall" style="display: none;">
    <p>Incoming Call...</p>
    <button id="acceptCall">Accept</button>
    <button id="rejectCall">Reject</button>
</div>


<script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>
<script>
const socket = io("https://vfycall.onrender.com/");

let localStream;
let peerConnection;
const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
let roomID;
let callTimer;
let callStartTime;

// Ringtone for Incoming Call
const ringtone = new Audio("https://github.com/Vivekmasona/vfy-fm/raw/refs/heads/main/sound/ms.mp3");
ringtone.loop = true;

// Get Popup Elements
const incomingCallPopup = document.getElementById('incomingCall');
const callTimerElement = document.getElementById('callTimer');
const acceptCallButton = document.getElementById('acceptCall');
const rejectCallButton = document.getElementById('rejectCall');
const endCallButton = document.getElementById('endCall');

// Automatically join room if sessionId is found in localStorage
window.addEventListener('load', () => {
    roomID = localStorage.getItem('sessionId');
    if (roomID) {
        socket.emit('join-room', roomID);
        document.getElementById('callUser').disabled = false;
        alert(`Automatically Joined Room: ${roomID}`);
    } else {
        alert('Session ID not found. Please check if it is saved correctly.');
    }
});

// Call User
document.getElementById('callUser').addEventListener('click', async () => {
    socket.emit('call-request', { roomID });
    document.getElementById('callStatus').innerText = 'Calling...';
});

// Incoming Call Popup
socket.on('incoming-call', ({ from }) => {
    incomingCallPopup.style.display = 'flex';
    ringtone.play();
    document.getElementById('callStatus').innerText = 'Incoming Call...';

    // Accept Call
    acceptCallButton.onclick = async () => {
        ringtone.pause();
        ringtone.currentTime = 0;
        socket.emit('call-accepted', { to: from });
        document.getElementById('callStatus').innerText = 'Connecting...';
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        peerConnection = new RTCPeerConnection(config);
        peerConnection.addTrack(localStream.getTracks()[0], localStream);

        peerConnection.ontrack = (event) => {
            const remoteAudio = new Audio();
            remoteAudio.srcObject = event.streams[0];
            remoteAudio.play();
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('candidate', { candidate: event.candidate, roomID });
            }
        };

        document.getElementById('callStatus').innerText = 'Connected';
        endCallButton.style.display = 'inline';
        callTimerElement.style.display = 'inline';
        startCallTimer();
    };

    // Reject Call
    rejectCallButton.onclick = () => {
        ringtone.pause();
        ringtone.currentTime = 0;
        socket.emit('call-rejected', { to: from });
        document.getElementById('callStatus').innerText = 'Call Rejected';
    };
});

// Call Accepted
socket.on('call-accepted', async () => {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    peerConnection = new RTCPeerConnection(config);
    peerConnection.addTrack(localStream.getTracks()[0], localStream);

    peerConnection.ontrack = (event) => {
        const remoteAudio = new Audio();
        remoteAudio.srcObject = event.streams[0];
        remoteAudio.play();
    };

    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit('candidate', { candidate: event.candidate, roomID });
        }
    };

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit('offer', { offer, roomID });

    document.getElementById('callStatus').innerText = 'Connected';
    endCallButton.style.display = 'inline';
    callTimerElement.style.display = 'inline';
    startCallTimer();
});

// End Call
endCallButton.addEventListener('click', () => {
    socket.emit('end-call', roomID);
    endCall();
});

socket.on('call-ended', () => {
    endCall();
});

function endCall() {
    if (peerConnection) peerConnection.close();
    peerConnection = null;
    document.getElementById('callStatus').innerText = 'Call Ended';
    endCallButton.style.display = 'none';
    stopCallTimer();
}

function startCallTimer() {
    callStartTime = new Date();
    callTimer = setInterval(() => {
        const now = new Date();
        const elapsed = Math.floor((now - callStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        callTimerElement.innerText = `${minutes}:${seconds}`;
    }, 1000);
}

function stopCallTimer() {
    clearInterval(callTimer);
    callTimerElement.innerText = '00:00';
}
</script>
