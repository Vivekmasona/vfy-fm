<style>#volumeSlider {
  /* Remove default browser styles */
  -webkit-appearance: none;
  appearance: none;
  width: 100%; /* Set the width to 100% of its container */
  height: 10px; /* Set the height as desired */
  background: #15e2f5; /* Background color of the slider track */
  border-radius: 5px; /* Rounded corners for the track */
}

#volumeSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 10px; /* Set the width of the thumb */
  height: 10px; /* Set the height of the thumb */
  background: red; /* Color of the thumb */
  border-radius: 50%; /* Make the thumb circular */
  cursor: pointer; /* Show a pointer cursor on hover */
}

#volumeSlider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: #15e2f5;
  border-radius: 50%;
  cursor: pointer;
}

/* Style the track when the slider is in its default state */
#volumeSlider::-webkit-slider-runnable-track {
  height: 10px; /* Set the height of the track */
  background: #15e2f5; /* Background color of the track */
  border-radius: 5px; /* Rounded corners for the track */
}

/* Style the track when the slider is in its disabled state */
#volumeSlider:disabled::-webkit-slider-runnable-track {
  background: #15e2f5; /* You can change this color to make it distinct when disabled */
}

/* Style the thumb when the slider is in its disabled state */
#volumeSlider:disabled::-webkit-slider-thumb {
  background: #15e2f5; /* You can change this color to make it distinct when disabled */
}</style>

<div id="thumbnailContainer" class="full-screen-container">
        <div class="square-frame">
            <!-- The generated thumbnail image will be inserted here -->
            <img src="" alt="vivekfy:-Download kar Lo yarr" class="img-fluid" />
        </div>
    </div>

    

<script>
var op = new Audio();
op.src = '/effect/Click.mp3';
</script>
<style>

@-webkit-keyframes hue {
100% { -webkit-filter:hue-rotate(360deg); }
}
img:hover {
-webkit-animation:hue 1s linear infinite;
}
	</style>
	

<script src='demo-to-prevent-copy-paste-on-blogger_files/googleapis.js'></script><script type='text/javascript'> if(typeof document.onselectstart!="undefined" ) {document.onselectstart=new Function ("return false" ); } else{document.onmousedown=new Function ("return false" );document.onmouseup=new Function ("return false"); } </script>

<vivek href="#" onmousedown="op.play()">



<!doctype html>
<meta content='width=device-width, initial-scale=1.0' name='viewport'>
   
   </meta>
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    
    <style>
#soundController {
            color: yellow;
            background: rgb(245,182,64);
background: linear-gradient(90deg, rgba(245,182,64,1) 14%, rgba(86,109,126,1) 59%, rgba(0,0,0,1) 100%);

}

#img {
  
  border-style: solid;
  border-color: coral;
}
        #audioPlayer {
            width: 100%;
        }

        #controls {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #playButton {
            cursor: pointer;
            font-size: 44px;
            margin-right: 2px;
        }

        #backwardButton {
            cursor: pointer;
            font-size: 28px;
            margin-right: 2px;
        }

        #forwardButton {
            cursor: pointer;
            font-size: 0px;
            margin-right: 4px;
        }

        /* Style for the sound controller container */
        #soundController {
            display: flex;
            align-items: center;
        }

        /* Style for the volume icon */
        #soundIcon {
            cursor: pointer;
color :#000;
            font-size: 24px;
            margin-right: 10px;
        }

        #progressBar {
            flex: 1;
            height: 10px;
            background-color: #15e2f5;
		position: relative;
        }

        #progressBarInner {
            height: 100%;
            width: 0;
            background: rgb(86,109,126);
background: linear-gradient(90deg, rgba(86,109,126,1) 59%, rgba(255,68,28,1) 100%);
        }


        #timeDisplay {
		color: rgba(86,109,126,1);
        
            text-align: center;
            margin-top: 10px;
background-color: #15E2F5;
        }
    </style>

<div class="myfooter">
<audio id="audioPlayer" autoplay>


	
            Your browser does not support the audio element.
        </audio>
	
    
    <div id="audioContainer">
<div id="progressBar">
            <div id="progressBarInner"></div>
        </div>
	    
        

        <div id="controls">
            <img src="/img/logo.png" alt="vivekfy" width="50" height="50" style="margin-top:2px;margin-right:4" />
            <div id="backwardButton"><i class="fa fa-backward" style="font-size:28px;color:#15E2F5"></i></div>
		<div id="playButton"><i class="fa fa-pause-circle-o" style="font-size:48px;color:#15E2F5"></i></div>
		
		<div id="forwardButton"><i class="fa fa-forward" style="font-size:28px;color:#15E2F5"></i></div> <!-- Forward button -->
            <div id="loopButton">&#8634;</div> <!-- Loop button -->
               <i class="fa fa-heart" style="font-size:2px;color:transparent"></i>
            <!-- Sound controller (volume control) with icon -->
            <div id="soundController">
                <div id="soundIcon"><i class='fa fa-volume-up' style='font-size:30px;color:#566D7E'></i></div> <!-- Volume icon -->
                <input type="range" min="0" max="1" step="0.01" value="1" id="volumeSlider" />
		
            </div>
        </div>

        <div id="timeDisplay">
            <span id="currentTime">0:00</span> / <span id="totalDuration">0:00</span>
        </div>

        
    </div>
</div>

    <script>
        // Function to format time in minutes and seconds
        function formatTime(timeInSeconds) {
            var minutes = Math.floor(timeInSeconds / 60);
            var seconds = Math.floor(timeInSeconds % 60);
            return minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
        }

        // Function to get the URL parameter by name
        function getUrlParameter(name) {
            name = name.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // Get the 'url' parameter from the URL
        var audioUrl = getUrlParameter('url');

        // Set the audio source to the retrieved URL
        var audioPlayer = document.getElementById('audioPlayer');
        audioPlayer.src = audioUrl;
	   
	    // Automatically skip to 20 seconds when the audio starts playing
// audioPlayer.addEventListener('play', function() {
   // audioPlayer.currentTime = 20; // Skip to 20 seconds
// });
	    

        // Play/Pause functionality
        var playButton = document.getElementById('playButton');
        playButton.addEventListener('click', function() {
            if (audioPlayer.paused) {
                audioPlayer.play();
                playButton.innerHTML = '<i class="fa fa-pause-circle-o" style="font-size:48px;color:#15E2F5"></i>'; // Pause icon
            } else {
                audioPlayer.pause();
                playButton.innerHTML = '<i class="fa fa-play-circle-o" style="font-size:48px;color:#15E2F5"></i>'; // Play icon
            }
        });
// Backward functionality
var backwardButton = document.getElementById('backwardButton');
backwardButton.addEventListener('click', function() {
    var currentTime = audioPlayer.currentTime;
    var skipTime = 10; // Adjust this value to skip backward by the desired amount of seconds

    // Calculate the new time after skipping backward
    var newTime = currentTime - skipTime;

    // Ensure the new time is not negative
    if (newTime >= 0) {
        audioPlayer.currentTime = newTime;
    }
});

	    

        // Sound on/off functionality
        var soundIcon = document.getElementById('soundIcon');
        soundIcon.addEventListener('click', function() {
            if (audioPlayer.volume === 0) {
                audioPlayer.volume = 1; // Turn the sound on
                soundIcon.innerHTML = 'ðŸŽ§'; // Volume icon
            } else {
                audioPlayer.volume = 0; // Mute the sound
                soundIcon.innerHTML = '&#128263;'; // Muted speaker icon
            }
        });

        // Forward functionality
        var forwardButton = document.getElementById('forwardButton');
        forwardButton.addEventListener('click', function() {
            var currentTime = audioPlayer.currentTime;
            var duration = audioPlayer.duration;
            var skipTime = 10; // Adjust this value to skip forward by the desired amount of seconds

            // Calculate the new time after skipping forward
            var newTime = currentTime + skipTime;

            // Ensure the new time does not exceed the duration of the audio
            if (newTime < duration) {
                audioPlayer.currentTime = newTime;
            }
        });
	    // Loop functionality
var loopButton = document.getElementById('loopButton');
loopButton.addEventListener('click', function() {
    if (audioPlayer.loop) {
        audioPlayer.loop = false; // Disable looping
        loopButton.style.color = 'red'; // Change the button color to indicate looping is off
    } else {
        audioPlayer.loop = true; // Enable looping
        loopButton.style.color = '#15e2f5'; // Change the button color to indicate looping is on
    }
});

        // Update time display as audio plays
        var progressBar = document.getElementById('progressBar');
        var progressBarInner = document.getElementById('progressBarInner');
        var currentTimeDisplay = document.getElementById('currentTime');
        var totalDurationDisplay = document.getElementById('totalDuration');

        audioPlayer.addEventListener('timeupdate', function() {
            var currentTime = audioPlayer.currentTime;
            var duration = audioPlayer.duration;

            // Update current time and total duration
            currentTimeDisplay.textContent = formatTime(currentTime);
            totalDurationDisplay.textContent = formatTime(duration);

            // Update progress bar
            var progress = (currentTime / duration) * 100;
            progressBarInner.style.width = progress + '%';
        });

        // Get the volume slider element
        var volumeSlider = document.getElementById('volumeSlider');

        // Set the initial volume to 1 (full volume)
        audioPlayer.volume = 1;

        // Update the volume when the slider is moved
        volumeSlider.addEventListener('input', function() {
            audioPlayer.volume = volumeSlider.value;
        });
    </script>

  



<script>
        function getVideoIdFromUrl(url) {
            const shortUrlMatch = url.match(/youtu.be\/([^?]+)/);
            if (shortUrlMatch && shortUrlMatch.length > 1) {
                return shortUrlMatch[1];
            }
        
            const regularUrlMatch = url.match(/[?&]v=([^&]+)/);
            if (regularUrlMatch && regularUrlMatch.length > 1) {
                return regularUrlMatch[1];
            }
        
            return null;
        }
        
        // Get the URL parameter from the query string
        const urlParam = new URLSearchParams(window.location.search).get('url');
        
        if (urlParam) {
            const videoId = getVideoIdFromUrl(urlParam);
        
            if (videoId) {
                const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
                const thumbnailImg = document.querySelector('#thumbnailContainer .img-fluid');
                thumbnailImg.src = thumbnailUrl;
            }
        }
    </script>



</!doctype>

<style>* {
	-webkit-box-sizing: border-box;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}
body {
	font: 400 1rem / normal Inter, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
		Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
}

.myfooter {
	position: fixed;
	left: 0;
	bottom: 0;
	width: 100%;
	background-color: #566D7E;
	color: #fff;
	text-align: center;
}</style>




<style>
    /* Center the square frame */
    .full-screen-container {
        width: 95vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* Define the square frame with a fixed size */
    .square-frame {
        width: 90%; /* Adjusted to reduce the border size */
        height: auto; /* Adjusted to reduce the border size */
    }

    /* Style the thumbnail image */
    .img-fluid {
        max-width: 100%; /* Ensure the image fits within the frame */
        max-height: 100%; /* Ensure the image maintains its aspect ratio */
        display: block; /* Remove any default inline spacing */
        margin: auto; /* Center the image horizontally and vertically */
        border: 4px solid transparent; /* Add a transparent border with 4 pixels width */
        box-shadow: 0 0 10px rgba(255, 0, 0, 0.7); /* Add a red glowing shadow */
        transition: border 0.3s, box-shadow 0.3s; /* Transition for border and shadow */
        transform-origin: center; /* Set the rotation origin */
        border-radius: 5%; /* Make the image round */
        animation: rotate360 118s linear infinite; /* Rotate the image infinitely */
    }

    /* Animation for rotation */
    @keyframes rotate360 {
        from {
            transform: rotate(0deg);
        }
        to {
            transform: rotate(360deg);
        }
    }
</style>








<style>

body {
  font-family: Arial, Helvetica, "Liberation Sans", FreeSans, sans-serif;
  background-color: #000;
  margin:0;
  padding:0;
  border-width:0;
}

</style>
<script>


"use strict";

/* inspired by the ideas given by Louis Hoebregts in his pen :
https://codepen.io/Mamboleoo/full/XWJPxpZ */

window.addEventListener("load",function() {

  const initSpeed = 1;
  const rMin = 1;
  const rMax = 10;
  let canv, ctx;   // canvas and context : global variables (I know :( )
  let maxx, maxy;  // canvas sizes (in pixels)
  let particles;
  let click;
  let initDir;
  let noiseInitDir;
  let mouse = {x: 0, y: 0};
  let org = {x: 0, y: 0};
  let mouseMoved = false;
  let hue;
// shortcuts for Math.…

  const mrandom = Math.random;
  const mfloor = Math.floor;
  const mround = Math.round;
  const mceil = Math.ceil;
  const mabs = Math.abs;
  const mmin = Math.min;
  const mmax = Math.max;

  const mPI = Math.PI;
  const mPIS2 = Math.PI / 2;
  const m2PI = Math.PI * 2;
  const msin = Math.sin;
  const mcos = Math.cos;
  const matan2 = Math.atan2;

  const mhypot = Math.hypot;
  const msqrt = Math.sqrt;

  const rac3   = msqrt(3);
  const rac3s2 = rac3 / 2;
  const mPIS3 = Math.PI / 3;

//-----------------------------------------------------------------------------
// miscellaneous functions
//-----------------------------------------------------------------------------

  function alea (min, max) {
// random number [min..max[ . If no max is provided, [0..min[

    if (typeof max == 'undefined') return min * mrandom();
    return min + (max - min) * mrandom();
  }

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  function intAlea (min, max) {
// random integer number [min..max[ . If no max is provided, [0..min[

    if (typeof max == 'undefined') {
      max = min; min = 0;
    }
    return mfloor(min + (max - min) * mrandom());
  } // intAlea

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  function NoiseGen(rndFunc, period, nbHarmonics, attenHarmonics, lowValue = 0, highValue = 1) {

/* this function returns a function which can be used as a noise generator
   the returned functions takes no parameter : it is supposed to be called for
   consecutive, evenly spaced points of time or space.
- rndFunc is the random generator function used. It must return a value in the range
[0..1[. If a falsy value is provided (0, false, null, undefined..) Math.random will be used.
- period determines the speed of variation of the returned value. The higher
period is, the slowlier the value will change in the noise signal. It must be
a positive, non zero value (typically a few hundreds).
- nbHarmonics is an integer giving the number of harmonics used to generate the signal.
With 0 or 1, a single, smooth signal will be generated
With 2 or more, internally generated signals of periods up to period / 2, period / 3, will be added.
nbHarmonics should be kept as low as possible, since every added harmonic increases the
computation time significantly.
- attenHarmonics is a float number which should stay in the interval 0..1.
During harmonics generation, the amplitude of the signal is multiplied by
attenHarmonics, with respect to the immediatly lower level harmonic.
attenHarmonics = 0 results in no harmonics at all. attenHarmonics > 1 results in
harmonics greater than the fundamental, whith the highest harmonics beeing the
most important. This is not usually the desired behaviour.
lowValue and highValue are optional floating values. Despite the names, it
it is not required that highValue > lowValue. The
returned value will be scaled to the range lowValue..highValue
(without strict warranty about the limits beeing reached or exceeded, due to
the finite precision of floating numbers)

*/

  let arP0 = [];  // 'preceeding value' for each harmonic
  let arP1 = [];  // 'succeding value'
  let amplitudes = []; // amplitudes oh harmonics
  let increments = []; // n / period, wich will be added to phases for every point
  let phases = [];
  let globAmplitude = 0;
  if (!rndFunc) rndFunc = Math.random; // default value for rndFunc
  if (nbHarmonics < 1) nbHarmonics = 1;

  for (let kh = 1; kh <= nbHarmonics; ++ kh) {
    arP0[kh] = rndFunc();
    arP1[kh] = rndFunc();
    amplitudes[kh] = (kh == 1) ? 1 : (amplitudes[kh - 1] * attenHarmonics);
    globAmplitude += amplitudes[kh];
    increments[kh] = kh / period;
    phases[kh] = rndFunc();
  } // for kh

/* normalize amplitudes */
  amplitudes.forEach ((value, kh) => amplitudes[kh] = value / globAmplitude * (highValue - lowValue))

/* returned function here */
  return function () {
    let pf, pfl;
    let signal = 0;
    for (let kh = nbHarmonics; kh >= 1; --kh) {
      pf = phases[kh] += increments[kh];
      if (phases[kh] >= 1) {
        pf = phases[kh] -= 1;
        arP0[kh] = arP1[kh];
        arP1[kh] = rndFunc();
      } // if full period reached
      pfl = pf * pf * (3 - 2 * pf); // always 0..1, but smoother
      signal += (arP0[kh] * (1 - pfl) + arP1[kh] * pfl) * amplitudes[kh];
    } // for kh
    return signal + lowValue;
  } // returned function
  } // NoiseGen

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/* returns intermediate point between p0 and p1,
  alpha = 0 will return p0, alpha = 1 will return p1
  values of alpha outside [0,1] may be used to compute points outside the p0-p1 segment
*/
  function intermediate (p0, p1, alpha) {

    return [(1 - alpha) * p0[0] + alpha * p1[0],
            (1 - alpha) * p0[1] + alpha * p1[1]];
  } // function intermediate

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  function distance (p0, p1) {

/* distance between points */

    return mhypot (p0[0] - p1[0], p0[1] - p1[1]);

  } // function distance

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  function randomElement(array) {
    return array[intAlea(array.length)];
  } // randomElement

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  function removeElement(array, element) {
    let idx = array.indexOf(element);
    if (idx == -1) throw ('Bug ! indexOf -1 in removeElement');
    array.splice(idx, 1);
  } // removeElement


//-----------------------------------------------------------------------------
function clonePoint(p) {
  return [p[0],p[1]];
}

//-----------------------------------------------------------------------------
function Particle () {

  this.x = org.x;
  this.y = org.y;
//  this.dir = initDir + alea(-mPI / 10, mPI / 10);
  this.dir = alea(m2PI);
  this.speed = initSpeed * alea(0.8, 1.4);

  this.genddir = NoiseGen(null, 100, 2, 0.8, -0.03, 0.03);

  this.r = rMin;

//  this.color1 = `hsl(${intAlea(360)},100%,50%)`;
  this.color1 = `hsl(${hue}, 100%, ${alea(20,80)}%)`;
  hue = (hue + intAlea( -5, 5)) % 360;

} // Particle

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Particle.prototype.move = function () {

  this.dir = (this.dir + this.genddir()) % m2PI;
  this.speed += 0.01;

  this.r = mmin(this.r + 0.1,  rMax);
  this.x += this.speed * mcos(this.dir);
  this.y += this.speed * msin(this.dir);

  if (this.y < -this.r || this.y > maxy + this.r || this.x < -this.r || this.x > maxx + this.r) return false;

  return true;
} // Particle.move

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Particle.prototype.draw = function () {

  ctx.beginPath();
  ctx.arc(this.x, this.y,this.r,0,m2PI);
  ctx.fillStyle = this.color1;
  ctx.fill();

} // Particle.draw

//-----------------------------------------------------------------------------
// returns false if nothing can be done, true if drawing done

function startOver() {

// canvas dimensions

  maxx = window.innerWidth;
  maxy = window.innerHeight;

  if (maxx < 10) return false;

  canv.style.left = ((window.innerWidth ) - maxx) / 2 + 'px';
  canv.style.top = ((window.innerHeight ) - maxy) / 2 + 'px';

  ctx.canvas.width = maxx;
  ctx.canvas.height = maxy;
  ctx.lineJoin = 'round';   // placed here because reset when canvas resized
  noiseInitDir = NoiseGen(null, 200,0,0,-0.03,0.03);
  hue = intAlea(360);
  if (org.x == 0 && org.y == 0)
    org = {x: maxx / 2, y: maxy / 2};
  mouse = {x: maxx / 2, y: maxy / 2};
  particles = [];

  initDir = alea(m2PI);

  return true; // ok

} // startOver

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function mouseMove(event) {
  mouse.x = event.clientX;
  mouse.y = event.clientY;
  mouseMoved = true;
} // mouseMove

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function mouseClick() {
  org.x = event.clientX;
  org.y = event.clientY;
  click = true;
} // mouseMove

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
let animate;
{ // scope for animate

let still = 0;
let tStampPre = 0;

animate = function (tStamp) {

  if (tStampPre == 0) tStampPre = tStamp;

  if (click && startOver()) click = false;
  if (particles) {

// move origin point

    if (mouseMoved) {
      still = 1000; // moving : restart chronometer
      mouseMoved = false;
    }

    if (still > 0) {
      still += tStampPre - tStamp;
      if (still <= 0) { // does not move : take mouse position
//        org = {x: mouse.x, y: mouse.y}; no, not really interesting
      }
    }
    tStampPre = tStamp;

    initDir += noiseInitDir();
    initDir %= m2PI;
    ctx.fillStyle = 'rgba(0,0,0,0.03)';
    ctx.fillRect(0, 0, maxx, maxy);
    if (particles.length < 300) {
      particles.push(new Particle());
    }
    particles.forEach((part,k) => {
      if (part.move() == false ) {
        removeElement(particles, part);
      } else part.draw();
    });
  }
  window.requestAnimationFrame(animate);

} // animate
} // scope for animate
//------------------------------------------------------------------------
//------------------------------------------------------------------------
// beginning of execution

  {
    canv = document.createElement('canvas');
    canv.style.position="absolute";
    document.body.appendChild(canv);
    ctx = canv.getContext('2d');
  } // canvas creation

  window.addEventListener('click',mouseClick);

  window.requestAnimationFrame(animate);
  canv.addEventListener('mousemove',mouseMove);
  click = true; // to run startOver

}); // window load listener


</script>



